#include "iostream"
#include "vector"
using namespace std;

/// Итераторы - некая оболочка над указателями, которая определяет логику поведения как будут работать указатели
/// Они будут по разному работать для связного списка или вектора и тд
//int arr[] = {2, 6, 9};
//// Цель вывести на экран элемент массива под индексом 1
//// Способ 1: указав номер элемента массива
//cout << arr[1] << endl;
//// Способ 2: указателю на массив с исп-ем арифметики указателей перейти на один шаг (битов равное однмоу элементу)
//// и разименовав этот адрес памяти, где хранится элемент под номером 1:
//cout << *(arr+1) << endl;  // возвращает итератор, который смещен от итератора iter на n позиций вперед
// итераторы имеют только контейнеры, адаптеры контейнеров — типы std::stack, std::queue и std::priority_queue итераторов не имеют

int main(){
    vector<int> myvector = {1, 9, 44, 32, 676, 78};
    cout << myvector[1] << endl;
    // в большинстве контейнеров stl оператор [] не перегружен
    // и реализация доступа к элементам таких контейнеров и осуществляется с помощью итераторов

    vector<int>::iterator it; // это итератор типа данных вектора типа int
    it = myvector.begin(); // это метод который возвращает итератор типа myvector

    cout << *it << endl;
    // раз мы получили доступ к данным, то мы можем их изменить (не всегда - const)
     *it = 1000;
    cout << *it << endl;
    it++;
    // >, >=, <, <=: операции сравнения. Один итератор больше другого, если указывает на элемент, который ближе к концу
    // Итераторы для типов std::forward_list, std::unordered_set и std::unordered_map не поддерживают операции --, -= и -
    cout << *it << endl;
    --it;  // перемещение итератора назад для обращения к предыдущему элементу. Итераторы контейнера forward_list не поддерживают операцию декремента
    it+=2; //  перемещает итератор на n позиций вперед
    cout << *it << endl;
    it--;
    // Операции +=, -=, +, -, <, <=, >, >= и <=> поддерживаются только итераторами произвольного доступа (итераторы контейнеров std::vector, array и deque)
    cout << *it << endl;
    // Итераторы для типа std::list поддерживают операции инкремента и декремента, но не поддерживаются операции +=, -=, + и -. Те же ограничения имеют итераторы контейнеров std::map и std::set
    // iter1 != iter2: два итератора не равны, если они указывают на разные элементы
    cout << "auto iterator:" << endl;
    for(auto i = myvector.begin(); i != myvector.end(); i++){ // метод указывающий на область памяти сразу за вектором
        cout << *i << endl;
    }
    // Если контейнер представляет константу, то для обращения к элементам этого контейнера можно использовать только константный итератор (тип const_iterator).
    // для типов std::set (множество) и std::map (словарь) доступны только константные итераторы.
    cout << "const iterator:" << endl;
    // константный интератор (не можем изменить данные - только считывать)
    vector<int>:: const_iterator consti = myvector.cbegin();
    while(consti != myvector.cend()){
        cout << *consti << endl;
        ++consti;
    }
    //Реверсивные итераторы позволяют перебирать элементы контейнера в обратном направлении.
    //  const_reverse_iterator - crbegin() и crend()
    cout << "reverse_iterator:" << endl;
    // можем начать итерироваться с конца:
    vector<int>:: reverse_iterator ri = myvector.rbegin();
    for( ri; ri != myvector.rend(); ri++){
        cout << *ri << endl;
    }

    // Итераторы для массивов
    int data[]{4, 5, 6, 7, 8};
    auto iter = std::begin(data);
    auto end = std::end(data);
    while(iter != std::end(data)){
        cout << *iter << endl;
    }

    // чтобы итерироваться с какого то конкретного элемента:
    // cout << *(it+3) << endl;  // не всегда есть возможность так, поэтмоу через итераторы:
    cout << "Avance:" << endl;
    vector<int>:: iterator il = myvector.begin();
    advance(il, 3); // переведи итератор на 3 шага
    cout << *il << endl;

    cout << "Insert:" << endl;
    myvector.insert(il, 55);
    for(vector<int>:: iterator n = myvector.begin(); n != myvector.end(); n++){
        cout << *n << endl;
    }
    // добавить в контейнер какую-то часть другого контейнера c insert()
    // добавляем в конец вектора numbers из массива data элементы со 2-го по предпоследний
    myvector.insert(myvector.end(), std::begin(data) + 1, std::end(data)-1);
    for (auto iter {myvector.begin()}; iter != myvector.end(); ++iter)
    {
        std::cout << *iter << "\t";
    }
    cout << "Erase:" << endl;
    vector<int>::iterator itErase = myvector.begin();
    myvector.erase(itErase);  // удаляет элемент на который указывает итератор
    for(vector<int>:: iterator n = myvector.begin(); n != myvector.end(); n++){
        cout << *n << endl;
    }
    cout << "Erase2:" << endl;
    vector<int>::iterator itErase2 = myvector.begin();
    myvector.erase(itErase2, itErase2+2); // удаляет диапозон элементов на который указывает итератор
    for(vector<int>:: iterator n = myvector.begin(); n != myvector.end(); n++){
        cout << *n << endl;
    }

    return 0;
}
// При работе с контейнерами следует учитывать, что добавление или удаление элементов в контейнере
// может привести к тому, что все текущие итераторы для данного контейнера, а также ссылки и
// указатели на его элементы станут недопустимыми.
// Поэтому при добавлении или удалении элементов в контейнере в общем случае следует перестать
// использовать текущие итераторы для этого контейнера.